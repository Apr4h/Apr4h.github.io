---
title: Catching Malware In Memory Part 1 - Detecting Process Injection
tags: [process injection, Windows, memory forensics, C#, programming, DFIR, P/Invoke, .NET Framework, DLL Injection]
layout: post
---

This post breaks down how to detect classic and reflective DLL injection on a live Windows host by enumerating running processes and their threads for signs of malicious code injection. I'll be using code snippets from my tool [GetInjectedThreads](https://github.com/Apr4h/GetInjectedThreads) throughout this post to explain the detection process and including screenshots of my tool's output to show detection of some common malware that primarily lives in-memory. While my tool currently finds injected threads and outputs information useful for responders, a Part 2 of this post will take it a step further, scanning identified processes for malware signatures and extracting useful configuration information from them! GetInjectedThreads is essentially a C# of Jared Atkinson's [Get-InjectedThread.ps1](https://gist.github.com/jaredcatkinson/23905d34537ce4b5b1818c3e6405c1d2) Which I'll also discuss below.

## Summary
Over time I've become increasingly curious as to how process injection works and how one might detect it. I've recently been using meterpreter and Cobalt Strike a lot, which both rely heavily on reflective DLL injection for execution of their second stages in memory. After doing some research, I decided I'd have a crack at writing some code to detect process injection and came across the following useful resources that I relied upon for writing this post and my tool:
- This [SpecterOps Post](https://posts.specterops.io/defenders-think-in-graphs-too-part-1-572524c71e91) by Jared Atkinson,
- This [2019 Blackhat Paper](https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All-wp.pdf) on Windows process injection, and
- Chapter 8 of [The Art of Memory Forensics](https://www.wiley.com/en-us/The+Art+of+Memory+Forensics:+Detecting+Malware+and+Threats+in+Windows,+Linux,+and+Mac+Memory-p-9781118825099)

While I chose to write my tool in C#, [P/Invoke](https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke) is required throughout to use unmanaged code from the Windows API to access process and thread memory as well as token information. Below is an overview of the process GetInjectedThreads uses to detect injection.

1. Enumerate all running processes and get a handle to each process via OpenProcess()
2. Iterate over each thread in the process' ProcessThreadCollection and get a handle to the thread via OpenThread()
3. Retrieve the base address of the thread's allocated memory via NtQueryInformationThread()
4. Retrieve the thread's [MEMORY_BASIC_INFORMATION](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memory_basic_information) structure passing its base address and the process handle to VirtualQueryEx()
5. If the thread's MEMORY_BASIC_INFORMATION indicates that the thread contains pages associated to physical storage (State = MEM_COMMIT) and those pages are NOT mapped to an executable or DLL on disk (Type != MEM_IMAGE), then it is highly likely that code injection has occurred. 

For each thread where likely injection has been detected:
1. Get a handle to the thread or process token
  - If a particular thread has its own token, it can be retrieved by calling OpenThreadToken()
  - If OpenThreadToken() returns false, the thread is likely using its parent process' token which is retrieved by calling OpenProcessToken()
2. Retrieve token information by passing the token handle to GetTokenInformation()
3. Read the contents of the thread and its process' memory via ReadProcessMemory()
4. Retrieve other useful thread/process-specific information via .NET methods, unmanaged code and WMI. 




