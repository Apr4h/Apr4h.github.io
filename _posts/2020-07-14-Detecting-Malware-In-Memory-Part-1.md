---
title: Catching Malware In Memory Part 1 - Detecting Process Injection
tags: [Process Injection, Windows, Memory Forensics, C#, Programming, DFIR, P/Invoke, .NET Framework, DLL Injection, Malware, meterpreter, Cobalt Strike]
layout: post
---

This post breaks down how to detect classic and reflective DLL injection on a live Windows host by enumerating running processes and their threads for signs of malicious code injection. I'll be using code snippets from my tool [GetInjectedThreads](https://github.com/Apr4h/GetInjectedThreads) throughout this post to explain the detection process and including screenshots of my tool's output to show detection of some common malware that primarily lives in-memory. While my tool currently finds injected threads and outputs information useful for responders, a Part 2 of this post will take it a step further, scanning identified processes for malware signatures and extracting useful configuration information from them! GetInjectedThreads is essentially a C# implementation of Jared Atkinson's [Get-InjectedThread.ps1](https://gist.github.com/jaredcatkinson/23905d34537ce4b5b1818c3e6405c1d2) Which I'll also discuss below.

## Summary
Over time I've become increasingly curious as to how process injection works and how one might detect it. I've recently been using meterpreter and Cobalt Strike a lot, which both rely heavily on reflective DLL injection for execution of their second stages in memory. After doing some research, I decided I'd have a crack at writing some code to detect process injection and came across the following useful resources that I relied upon for writing this post and my tool:
- This [SpecterOps Post](https://posts.specterops.io/defenders-think-in-graphs-too-part-1-572524c71e91) by Jared Atkinson, without which I would have been lost!
  - The post breaks down [Get-InjectedThread.ps1](https://gist.github.com/jaredcatkinson/23905d34537ce4b5b1818c3e6405c1d2) and details what information is collected from injected threads. I decided to collect the exact same information upon initial detection and output results to console in the same format.
- This [2019 Blackhat Paper](https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All-wp.pdf) on Windows process injection, and
- Chapter 8 of [The Art of Memory Forensics](https://www.wiley.com/en-us/The+Art+of+Memory+Forensics:+Detecting+Malware+and+Threats+in+Windows,+Linux,+and+Mac+Memory-p-9781118825099)

### Process Injection Overview
I won't go into a detailed explanation here, particularly as there are many different techniques for injecting code into another process, but at its crux, process injection always involves three key steps:

1. Allocating memory in the target process
2. Writing code into the allocated memory
3. Executing the code written to the target process

This image summarises the steps used in the type of DLL injection being detected here.
![dll injection](http://1.bp.blogspot.com/-NQx0mo7wOnw/UOr00ZmbtXI/AAAAAAAABag/oGjHH1YlttM/s1600/DLL%2BInjection-Functions.png)

### GetInjectedThreads Overview 
While I chose to write GetInjectedthreads in C#, [P/Invoke](https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke) is required throughout to use unmanaged code from the Windows API to access process and thread memory as well as token information. Below is an overview of the process GetInjectedThreads uses to detect injection.

1. Enumerate all running processes and get a handle to each process via [OpenProcess()](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)
2. Iterate over each thread in the process' ProcessThreadCollection and get a handle to the thread via [OpenThread()](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthread)
3. Retrieve the base address of the thread's allocated memory via [NtQueryInformationThread()](https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationthread)
4. Retrieve the thread's [MEMORY_BASIC_INFORMATION](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memory_basic_information) structure passing its base address and the process handle to [VirtualQueryEx()](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualqueryex)
5. If the thread's [MEMORY_BASIC_INFORMATION](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memory_basic_information) indicates that the thread contains pages associated to physical storage (State = MEM_COMMIT) and those pages are NOT mapped to an executable or DLL on disk (Type != MEM_IMAGE), then it is highly likely that code injection has occurred. 

For each thread where likely injection has been detected:
1. Get a handle to the thread or process token
  - If a particular thread has its own token, it can be retrieved by calling [OpenThreadToken()](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthreadtoken)
  - If [OpenThreadToken()](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthreadtoken) returns false, the thread is likely using its parent process' token which is retrieved by calling [OpenProcessToken()](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken)
2. Retrieve token information by passing the token handle to [GetTokenInformation()](https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation)
3. Read the contents of the thread and its process' memory via [ReadProcessMemory()](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory)
4. Retrieve other useful thread/process-specific information via .NET methods, unmanaged code and WMI. 

## Breaking Down GetInjectedThreads

### Housekeeping

Assuming that more than a single injected thread may be detected on a host and that information collected about injected threads could be useful in other programs, a List of InjectedThread objects is initialised before process enumeration occurs. Here's what information is collected and stored for each InjectedThread

```cs
 class InjectedThread
    {
        public string ProcessName { get; set; }
        public int ProcessID { get; set; }
        public string Path { get; set; }
        public string KernelPath { get; set; }
        public string CommandLine { get; set; }
        public bool PathMismatch { get; set; }
        public int ThreadId { get; set; }
        public string AllocatedMemoryProtection { get; set; }
        public string MemoryProtection { get; set; }
        public string MemoryState { get; set; }
        public string MemoryType { get; set; }
        public int BasePriority { get; set; }
        public bool IsUniqueThreadToken { get; set; }
        public string Integrity { get; set; }
        public string Privileges { get; set; }
        public string LogonId { get; set; }
        public string SecurityIdentifier { get; set; }
        public string Username { get; set; }
        public DateTime LogonSessionStartTime { get; set; }
        public string LogonType { get; set; }
        public string AuthenticationPackage { get; set; }
        public IntPtr BaseAddress { get; set; }
        public int Size { get; set; }
        public byte[] ProcessBytes { get; set; }
        public byte[] ThreadBytes { get; set; }
        public DateTime ThreadStartTime { get; set; }
        
        ...
```

GetInjectedThreads requires Administrator privileges, or specifically the SeDebugPrivilege privilege due to the nature of how it functions (accessing remote processes and their tokens, reading their paged memory, etc.) and a simple check for Admin privileges is included before process enumeration occurs. 
